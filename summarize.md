## QUESTION
* Q：怎么先保证测试代码的正确性？
* A: 没必要。测试代码永远比功能代码更简单。
* Q：第58页，这个测试只是向被测代码传递了一组不同的值。有意义吗?（createUrl函数，两个测试用例仅是传递的参数的值不同）
* A：没有本质的区别，以及视场景的重要性，则无需多组。
* Q: 何时以及为何要使用spy而非mock?
* A：所谓良性依赖例如内部调用的函数就用spy，而外部消耗大的依赖如外部异步API就用mock。
*    对于不确定的东西，就用mock
* Q：第41页，测试的步骤：先编写失败的测试，然后再编写最少的代码让这个测试通过？
* A: 测试驱动开发的需要，先写测试代码再写功能代码，此时可以先考虑失败的情况；如果写了功能代码后再写测试，容易遗漏测试条件。
*    实际工作中，尽量先写测试再写功能，实在不行也应写完功能后立即写测试

5. 感受：测试代码感觉很冗余，不过因为是完全互相独立的，所以维护成本也不高
6. 问题：依赖注入是针对被测代码吗？是不是将依赖外部化，将需要的函数或对象作为参数传递（生产环境传递真正的，测试环境传递测试替身）”是依赖注入的形式。直接在测试代码中，创建测试替身代替依赖，就不叫依赖注入？
7. 问题：有时候出现some of your tests did a full page reload!

## 总结
测试的对象
1. 同步函数的返回值
2. 异步函数的返回值
3. 函数是否被调用
4. 函数是否传递特定参数调用
5. 函数是否没有被调用
6. 函数被调用的次数
测试步骤
1. 先编写失败的测试，然后再编写最少的代码让这个测试通过
2. 第一批测试帮助我们梳理接口，后续测试帮助我们实现代码
3. 将注意力集中于手头的测试，其它的测试条件添加到列表
测试替身
1. 解决依赖
2. 测试代码中运行的函数，也就是主函数，直接运行（是唯一的）；内部调用的函数属于依赖，或外部依赖，就用测试替身
spike
1. 当实现不够明确时，先写测试是很困难的。当存有疑问时，应该在编写测试前先创建一个快速的、独立的spike
2. 有效+无效+网络丢失

## 第一章
### 测试与验证
* 测试：使用
* 验证：正确性
* 手动测试：洞察应用
`冰淇淋反模式`：错！自动化测试极端地集中在UI层
`测试金字塔`：底层测试最多，高层次的端到端测试最少
### 如何实现自动化测试？
1. 细化测试
2. 分而治之
3. 采用spike解决方案

## 第二章 测试驱动设计
测试应该能够让我们将想到的问题提出来，帮助发现细节，然后在这个过程中梳理出代码的接口。
### 概念
* `测试套件`，`测试文件`，`测试用例`
* `mocha`：测试引擎，识别和执行测试
* `chai`: 断言库
* `Istanbul`：评估代码覆盖率
* `Karma`：将代码和测试加载到不同的浏览器
* `sinon`：测试替身框架/工具
* `金丝雀测试`：验证开发环境是否正确安装
* `expect断言`：chai断言库的3种断言风格：assert, expect, should
* `三明治函数`：beforeEach和afterEach
* *`3-As模式`*：Arrange-Act-Assert(准备、行动、断言)
* *`正向测试`* *`反向测试`* *`异常测试`*
### tips
1. spicker解决方案。 测试、开发循序渐进、由小及大的好处。

### 2.1 开始
*编写测试的原则*
* 测试和测试套件*职责单一*：避免将多个独立的断言放在一个测试用例中（注意是独立，例如姓、名两个就不是独立的）
* 测试应该与代码相关，行为与业务相关: 得到业务分析师、产品负责人等团队其它成员反馈
### 2.2 正向测试 反向测试和异常测试
从编写一个相当简单的测试开始，不需要礼盒让它以完美的状态呈现
*FAIR*: 快速、自动化、独立、可重复
1. 正向测试：当前置条件满足时，验证代码的结果确实符合预期。
2. 反向测试：当前置条件或者输入不符合要求时，代码能优雅地进行处理。例如：边界情况、非法输入
3. 异常测试：代码以预期的方式抛出异常时，异常测试才应该通过。
```js
	// 异常测试注意包装函数
	it('should throw an exception if argument is missing', function () {
		var call = function () {
			isPalindrome();
		}

		// 如果传递的是一个函数，expect就会调用这个函数，并检查任何可能抛出的异常
		expect(call).to.throw(Error, 'Invalid argument');
	});
```
### 2.3 设计服务端代码
1. 纸笔书写条件——测试列表
2. 先将注意力放在函数的接口上（名称，参数，返回值类型），再关心具体实现（函数体）
```js
module.exports = function (word) {
	return true;  // 先直接return true
}
```
### 2.4 评估服务端代码覆盖率
覆盖率报告coverage文件夹中
1. 覆盖率报告非常有用，但不要过于依赖它
2. 覆盖率报告不会显示缺少测试，例如反向测试。可以通过*代码审查*来弥补

### 2.5-2.6 测试客户端代码
1. 将代码和测试加载到不同的浏览器 => 2. 执行测试 => 3. 断言预期结果 => 4. 生成执行报告
* 配置：`node node_modules/karma/bin/karma init`
* 客户端代码：使用普通函数取代module.exports
* Karma会帮助我们在HTML页面中导入JavaScript文件
* 【注意】JavaScript文件名不要包含空白字符

### 评估客户端代码覆盖率
配置preprocessors属性、reporters属性，依然在生成的coverage文件夹查看

## 第三章 异步测试 （同步测试是对函数返回值断言，异步测试在回调或promise完成后断言）
测试的步骤：
1. 编写失败的测试 
2. 编写最少的代码让这个测试通过
参数标识的机制

设置超时时限：
```js
this.timeout(10000);
```
### 测试promise
1. 使用done()进行测试：then+done
2. 返回promise的测试，return + then
3. 推荐：使用chai-as-promised: return expect(func())...to.eventually.eql
4. 推荐：结合eventually和done()，不是所有的工具都提供返回promise的功能：expect(func()...to.eventually.eql.notify
5. 为promise编写反向测试，只能验证Promise变成失败状态: expect(func())...to.be.rejected.notify
6. 为promise编写反向测试，验证是否传递了预期的错误信息: expect(func())...to.be.rejectedWith.notify

## 第四章 巧妙处理依赖
* 解决依赖问题的第一步时尽可能去除依赖
* 抽取函数，并将最少的数据作为参数传给它
* 如果函数中的依赖时内部的，就要通过*依赖注入*构建松耦合的代码
* 可以使用*测试替身*来取代真实的对象或函数
### 4.2 模块化设计
拆分函数（单一职责），为每一个函数编写自动化测试
### 4.3 尽量分离依赖
*不关心需要的值从哪来，不关心返回的值给谁用*
### 4.4 使用测试替身
代替真正的依赖对象，如window对象、API这些*外部依赖*，让自动化测试可以进行
#### 测试替身的类型
* fake 适用于测试但不能用于生产环境的实现
* stub 用于验证状态
* mock 用于验证行为
* spy 代理真实的依赖
### 4.5 依赖注入
依赖在调用时作为参数传递：
* 在生产环境中，可以向目标函数传递真正的函数或对象以供它使用；
* 在测试环境中，可以提供测试替身。
也就是通过参数传递代替直接创建一个依赖对象或从全局引用获取
### 4.6 交互测试
* 如果结果是确定的、可预测的，而且容易断定，那么就使用经验测试；
* 如果代码有复杂的依赖关系，而且依赖让代码不确定、难以预测、脆弱或耗时，那么就使用交互测试。
交互测试：在测试中不调用真正的外部依赖（如地理定位navigator.geolocation.getCurrentPosition）
### 4.7 使用Sinon清理测试代码
`frameworks: ['mocha', 'chai', 'sinon', 'sinon-chai']`
另有`karma-sinon`, `karma-sinon-chai`
Sinon的sandbox可以简化恢复原函数的过程
注意没有done参数
#### mock测试交互
* mock整个对象
* 检查被测函数与该mock代替的依赖是否进行了交互
* 用了测试替身重写该函数：验证传递的参数是否与withArgs中的指定参数相符，测试替身：mock函数替代getCurrentPosition
#### stub测试状态
* 需使用调用者返回returns函数中传入的值
* 验证onError函数返回的错误信息在DOM元素上显示，测试替身：用JSON对象模拟eror实例、DOM元素
#### spy拦截调用
* 验证函数是否被调用，验证函数是否以特定的参数被调用
* 依赖是良性的，可以真正的调用，例如内部依赖（调用的函数）
* spy只拦截和记录传给函数的参数，不会阻塞或绕过该调用

##第五章 Node.js测试驱动开发
### 5.1 从策略设计开始——适度即可
### 5.2 深入战略设计——测试优先
无需花费过多时间，随时添加


## API
### stub - callsFake
### stub - return
```js
	sandbox.stub(stockfetch.http, 'get').callsFake(function (url) {
		expect(url).to.be.eql('http://www.example.com');
		done();
		return {
			on: function () {}
		};
	});
```
### mock - anonymouse
```js
	var expectation = sinon.mock([methodName]);
```
### mock - never
```js
	var onError = sandbox.mock().never();
```
### expect - have property
断言：含有属性
```js
expect(geolocation).to.be.have.property('lat');
```
